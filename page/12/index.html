<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="ZJU SE">
<meta property="og:type" content="website">
<meta property="og:title" content="hys&#39;s blog">
<meta property="og:url" content="https://ShengAndXian.github.io/page/12/index.html">
<meta property="og:site_name" content="hys&#39;s blog">
<meta property="og:description" content="ZJU SE">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hys&#39;s blog">
<meta name="twitter:description" content="ZJU SE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ShengAndXian.github.io/page/12/"/>





  <title>hys's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hys's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习中的点滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71030-travel-plan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71030-travel-plan/" itemprop="url">PAT甲级1030 Travel Plan</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:50:02+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71030-travel-plan/" class="leancloud_visitors" data-flag-title="PAT甲级1030 Travel Plan">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1030 Travel Plan，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1030" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1030</a><br>解题分析：<br>这一题和1018 Public Bike Management类似，是dijkstra算法和DFS的应用，但比其稍微简单一点。程序使用了邻接链表储存整张图，我觉得这样一来不容易爆栈，使用邻接矩阵虽然简单但如果作为局部变量的话，节点数量一大就容易爆栈。解题的大致思路是，先用dijkstra算法计算出从给定的出发点到其他点的最短路径，这个过程不需要考虑cost，接下来深度搜索整张图，利用目的地点的最短路径做剪枝操作，即如果当前的路长大于目的地点的最短路径则不往下搜索，这样一来可以节省一些时间。走过的路长用全局变量length记录，费用用cost记录，最小费用用min_cost记录，当搜索到目的地节点时比较cost和min_cost，如果cost比min_cost小，则更新min_cost，清空stack，并将目的地节点放入stack，返回1，否则直接返回0。对于其他不是目的地节点的节点，如果有与之相连的点返回1，则该节点入栈，表明其在有最短路径和最小费用的路径上，<br>如果与之相连的点全部返回0，则直接返回0.DFS的时候注意在继续往下搜索时，要将当前节点设置为已访问，防止重复搜索造成死循环，当从当前点返回上一个节点时，要将当前节点设置为未访问，这样其他点才能继续访问之。最后按格式输出即可。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>

#define INFINITY 100000
struct node{
    int index;
    int distance;
    int cost;
    struct node *next;
};//储存相邻点和边的信息
struct city{
    int shortest_distance;
    int visited;
    struct node *ptr;
};//储存各个节点信息

void initialize(struct city G[]);
void connect(struct city G[] , int c1 , int c2 , int distance , int cost);
void dijkstra(struct city G[]);
int DFS(struct city G[] , int start);
void output(struct city G[]);

// 全局变量定义
int n , m , s , d;
int stack[500];
int top = -1;
int min_cost = INFINITY;
int cost = 0;
int length = 0;

int main(){
    struct city G[500];
    int c1 , c2;
    int distance , cost;
    int i;

    // 输入
    scanf("%d%d%d%d" , &n , &m , &s , &d);
    // 初始化
    initialize(G);
    // 连接
    for(i = 0;i < m;i++){
        scanf("%d%d%d%d" , &c1 , &c2 , &distance , &cost);
        connect(G , c1 , c2 , distance , cost);
        connect(G , c2 , c1 , distance , cost);
    }
    // 计算最短路径
    G[s].shortest_distance = 0;
    dijkstra(G);
    // 将所有点设置为未访问，否则会对DFS产生影响
    for(i = 0;i < n;i++)
        G[i].visited = 0;
    // 深度搜索整张图
    DFS(G , s);
    // 输出
    output(G);
}

// 初始化
void initialize(struct city G[]){
    int i;

    for(i = 0;i < n;i++){
        G[i].shortest_distance = INFINITY;
        G[i].visited = 0;
        G[i].ptr = NULL;
    }
}

// 连接两点
void connect(struct city G[] , int c1 , int c2 , int distance , int cost){
    struct node *ptr;

    ptr = (struct node *)malloc(sizeof(struct node));
    ptr->index = c2;
    ptr->distance = distance;
    ptr->cost = cost;
    ptr->next = G[c1].ptr;
    G[c1].ptr = ptr;
}

// 最短路径算法
void dijkstra(struct city G[]){
    int i;
    int min , index;
    int temp;
    struct node *ptr;

    while(1){
        min = INFINITY;
        for(i = 0;i < n;i++){
            if(G[i].visited == 0 && G[i].shortest_distance < min){
                min = G[i].shortest_distance;
                index = i;
            }
        }
        if(min == INFINITY)
            break;
        G[index].visited = 1;
        ptr = G[index].ptr;
        while(ptr != NULL){
            temp = G[index].shortest_distance + ptr->distance;
            if(temp < G[ptr->index].shortest_distance)
                G[ptr->index].shortest_distance = temp;
            ptr = ptr->next;
        }
    }   
}

// 深度搜索
int DFS(struct city G[] , int start){
    int flag = 0;
    struct node *ptr;

    // 如果当前点为目的地节点
    if(start == d){
        // 如果cost小于min_cost
        if(cost < min_cost){
            // 更新min_cost
            min_cost = cost;
            // 清空stack
            top = -1;
            // 将目的地节点放入stack
            stack[++top] = start;
            // 返回1
            return 1;
        }
        // 否则返回0
        else 
            return 0;
    }
    // 如果不是目的地节点，则先将其设置为已访问
    G[start].visited = 1;
    ptr = G[start].ptr;
    // 遍历相连的所有点
    while(ptr != NULL){
        // 更新length和cost
        length += ptr->distance;
        cost += ptr->cost;
        // 如果相连点没有访问过并且路长小于等于目的地节点的最短路径
        if(G[ptr->index].visited == 0 && length <= g[d].shortest_distance){="" 继续往下搜索，如果返回结果是1="" if(dfs(g="" ,="" ptr-="">index))
                // flag设置为1
                flag = 1;
        }
        // 还原length和cost
        length -= ptr->distance;
        cost -= ptr->cost;
        // 继续处理其他相连的点
        ptr = ptr->next;
    }
    // 向上一点返回时设置为未访问
    G[start].visited = 0;
    // 如果flag为1
    if(flag){
        // 将当前点放入stack
        stack[++top] = start;
        // 返回1
        return 1;
    }
    // 否则直接返回0
    else
        return 0;
}

void output(struct city G[]){
    int i;

    for(i = top;i >= 0;i--)
        printf("%d " , stack[i]);
    printf("%d %d" , G[d].shortest_distance , min_cost);
}

</=></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71029-median/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71029-median/" itemprop="url">PAT甲级1029 Median</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:47:51+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71029-median/" class="leancloud_visitors" data-flag-title="PAT甲级1029 Median">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1029 Median，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1029" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1029</a><br>解题分析：<br>题目其实很简单，但有一些坑。刚开始的时候我直接定义了3个有百万级别元素个数的数组，结果一运行就段错误，在网上查阅资料后，知道了本地变量存放在内存的栈空间，而栈空间比较小，因此定义了很大的数组后后爆栈。解决方法是将数组变为全局变量或用malloc分配内存。由于本人不太喜欢用全局变量，因此选用了malloc。malloc分配的内存位于内存的堆空间，堆空间的大小较大，因此不会爆掉。之后是排序问题，我没试过将两个序列合起来直接快排，看网上试过的人说好像会超时，具体就自己写一遍吧。我的方法类似于归并排序，用两个指针或者说索引遍历两个数组，然后一个一个排下来，最后输出中间值即可。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>

int main(){
    long int n1 , n2;
    long int i , j , k = 0;
    long int *arr1 , *arr2;
    long int *result;

    // 输入
    scanf("%ld" , &n1);
    arr1 = (long int *)malloc(sizeof(long int) * n1);
    for(i = 0;i < n1;i++)
        scanf("%ld" , &arr1[i]);
    scanf("%ld" , &n2);
    arr2 = (long int *)malloc(sizeof(long int) * n2);
    for(i = 0;i < n2;i++)
        scanf("%ld" , &arr2[i]);
    result = (long int *)malloc(sizeof(long int) * (n1 + n2));
    // 遍历两个数组
    for(i = 0 , j = 0;i != n1 && j != n2;){
        // 如果第一个数组的元素比第二个数组的元素小
        if(arr1[i] < arr2[j]){
            // 将第一个数组的元素放入最终的数组
            result[k++] = arr1[i++];
        }
        // 否则将第二个数组的元素放入最终的数组
        else{
            result[k++] = arr2[j++];
        }
    }
    // 如果第一个数组遍历完成
    if(i == n1){
        // 将第二个数组的剩余元素加入数组
        while(j != n2)
            result[k++] = arr2[j++];
    }
    // 同理
    else{
        while(i != n1)
            result[k++] = arr1[i++];
    }
    // 输出
    printf("%ld" , result[(k-1) / 2]);
}
</stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71028-list-sorting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71028-list-sorting/" itemprop="url">PAT甲级1028 List Sorting</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:45:40+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71028-list-sorting/" class="leancloud_visitors" data-flag-title="PAT甲级1028 List Sorting">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1028 List Sorting，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1028" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1028</a>解题分析：<br>一道简单的排序题，用qsort很轻松就可以解决。唯一需要注意的点是在对姓名或成绩排序时，有相同姓名或者成绩的人，需要根据ID再次排序。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct student{
    char ID[7];
    char name[9];
    int grade;
};//储存学生信息

void sort_ID(struct student S[] , int n);
void sort_name(struct student S[] , int n);
void sort_grade(struct student S[] , int n);
int compare_ID(const void *a , const void *b);
int compare_name(const void *a , const void *b);
int compare_grade(const void *a , const void *b);

int main(){
    int n , c;
    struct student S[100000];
    char ID[7];
    char name[9];
    int grade;
    int i;

    // 输入
    scanf("%d %d" , &n , &c);
    for(i = 0;i < n;i++){
        scanf("%s %s %d" , ID , name , &grade);
        strcpy(S[i].ID , ID);
        strcpy(S[i].name , name);
        S[i].grade = grade;
    }

    // 根据不同的c做不同排序
    switch(c){
        case 1:sort_ID(S , n);break;
        case 2:sort_name(S , n);break;
        case 3:sort_grade(S , n);break;
    }
}

// 对ID排序
void sort_ID(struct student S[] , int n){
    int i;

    qsort(S , n , sizeof(struct student) , compare_ID);
    for(i = 0;i < n;i++){
        printf("%s %s %d\n" , S[i].ID , S[i].name , S[i].grade);
    }
}

// 对姓名排序
void sort_name(struct student S[] , int n){
    int i;
    int start , end;

    qsort(S , n , sizeof(struct student) , compare_name);
    // 用start和end标记有相同姓名的序列的开始和结束
    start = end = 0;
    for(i = 1;i < n;i++){
        // 如果当前的学生和之前的学生有相同的姓名，则加入序列
        if(strcmp(S[i].name , S[start].name) == 0){
            end = i;
        }
        // 否则
        else{
            // 先对前面的序列按ID排序
            qsort(S + start , end - start + 1 , sizeof(struct student) , compare_ID);
            // 更新start和end为当前序号
            start = end = i;
        }
    }
    // 如果拥有相同姓名的序列在整个序列的最后
    if(start != end)
        qsort(S + start , end - start + 1 , sizeof(struct student) , compare_ID);
    for(i = 0;i < n;i++){
        printf("%s %s %d\n" , S[i].ID , S[i].name , S[i].grade);
    }
}

// 对成绩排序，和对姓名排序类似
void sort_grade(struct student S[] , int n){
    int i;
    int start , end;

    qsort(S , n , sizeof(struct student) , compare_grade);
    start = end = 0;
    for(i = 1;i < n;i++){
        if(S[i].grade == S[start].grade){
            end = i;
        }
        else{
            qsort(S + start , end - start + 1 , sizeof(struct student) , compare_ID);
            start = end = i;
        }
    }   
    if(start != end)
        qsort(S + start , end - start + 1 , sizeof(struct student) , compare_ID);
    for(i = 0;i < n;i++){
        printf("%s %s %d\n" , S[i].ID , S[i].name , S[i].grade);
    }
}

int compare_ID(const void *a , const void *b){
    return strcmp((*(struct student *)a).ID , (*(struct student*)b).ID);
}

int compare_name(const void *a , const void *b){
    return strcmp((*(struct student *)a).name , (*(struct student*)b).name);
}

int compare_grade(const void *a , const void *b){
    return (*(struct student *)a).grade - (*(struct student *)b).grade;
}
</string.h></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat1027-colors-in-mars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat1027-colors-in-mars/" itemprop="url">PAT1027 Colors in Mars</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:44:07+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat1027-colors-in-mars/" class="leancloud_visitors" data-flag-title="PAT1027 Colors in Mars">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT1027 Colors in Mars，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1027" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1027</a><br>解题分析：<br>水题，就不解释了。。。。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>

void get_rgb(int n , char s[]);

int main(){
    int n1 , n2 , n3;
    char s1[3] , s2[3] , s3[3];

    scanf("%d %d %d" , &n1 , &n2 , &n3);
    get_rgb(n1 , s1);
    get_rgb(n2 , s2);
    get_rgb(n3 , s3);
    printf("#%s%s%s" , s1 , s2 , s3);
}

void get_rgb(int n , char s[]){
    int i = 0;
    int temp;
    char s1[2];

    if(n == 0){
        s[0] = s[1] = '0';
        s[2] = '\0';
        return;
    }

    while(n != 0){
        temp = n % 13;
        if(temp < 10)
            s1[i] = temp + '0';
        else{
            switch(temp){
                case 10:s1[i] = 'A';break;
                case 11:s1[i] = 'B';break;
                case 12:s1[i] = 'C';break;
            }
        }
        n /= 13;
        i++;
    }

    if(i == 1){
        s1[i] = '0';
    }
    s[0] = s1[1];
    s[1] = s1[0];
    s[2] = '\0';
}
</stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71026-table-tennis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71026-table-tennis/" itemprop="url">PAT甲级1026 Table Tennis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:39:00+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71026-table-tennis/" class="leancloud_visitors" data-flag-title="PAT甲级1026 Table Tennis">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1026 Table Tennis，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1026" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1026</a><br>解题分析：<br>模拟题。玩家信息用一个结构体player储存，桌子信息用一个结构体table储存。首先，输入的玩家的到达时间是无序的，因此先要对他们排序。接着，每次遍历一遍所有桌子，选择结束时间最早的桌子，然后在玩家队列中选择到达时间小于等于最早结束时间的玩家，将其放入等待队列。因为方便对vip玩家的删除操作，所以程序中选择使用链表来模拟队列。所有符合条件的玩家入队后，选择其中一个玩家出队。这里需要注意：<br>1、如果桌子是vip桌，则要在等待队列中搜索vip玩家，如果有，则桌子要给第一个vip玩家，否则给第一个等待的人<br>2、如果桌子不是vip桌，并且第一个等待的人不是vip，则直接将桌子给他<br>3、如果桌子不是vip桌，但第一个等待的人是vip，则要判断这个时间点是否有vip桌空余，如果有，则将vip玩家安排到vip桌，否则，将vip玩家安排到当前桌。<br>如果等待队列中没有玩家，说明下一个玩家到达时已有空桌，如果该玩家是普通玩家，则安排序号最小的空桌，如果该玩家是vip玩家，则先安排序号最小的vip桌，如果没有空余的vip桌，再安排序号最小的普通桌。对于服务时间超过21点的，先假设对他们进行安排，但桌子的服务人数不更新。输出时按服务时间排序，服务时间超过21点的，不输出。另外注意输出等待时间时要四舍五入，具体在程序中有注释。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>

struct table{
    int vip;
    int current_time;
    int number;
};//储存桌子信息

struct player{
    int arrive_time;
    int play_time;
    int serve_time;
    float wait_time;
    int vip;
};//储存玩家信息

struct node{
    int index;
    struct node *next;
};//等待链表中的节点

void print_time(int n);
int compare_arrive(const void *a , const void *b);
int compare_serve(const void *a , const void *b);

int main(){
    struct player P[10000];
    struct table T[100];
    struct node *head;
    struct node *ptr , *rear;
    struct node *ptr1;
    int n;
    int hour , minute , second;
    int play_time;
    int vip;
    int k , m , vip_index;
    int i;
    int min;
    int temp;
    int start = 0;
    int index;
    int flag;

    // 输入玩家信息
    scanf("%d" , &n);
    for(i = 0;i < n;i++){
        scanf("%d:%d:%d %d %d" , &hour , &minute , &second , &play_time , &vip);
        // 时间转换成秒
        P[i].arrive_time = hour * 3600 + minute * 60 + second;
        // 玩的时间超过两小时要压缩成两小时
        if(play_time > 120)
            play_time = 120;
        P[i].play_time = play_time * 60;
        P[i].vip = vip;
    }
    // 输入桌子信息
    scanf("%d %d" , &k , &m);
    for(i = 1;i <= k;i++){="" t[i].vip="0;" t[i].number="0;" 从8点开始="" t[i].current_time="8" *="" 3600;="" }="" 输入vip桌子序号="" for(i="0;i" <="" m;i++){="" scanf("%d"="" ,="" &vip_index);="" t[vip_index].vip="1;" 对玩家序列排序="" qsort(p="" n="" sizeof(struct="" player)="" compare_arrive);="" 构建等待队列="" head="(struct" node="" *)malloc(sizeof(struct="" node));="" head-="">next = NULL;
    rear = head;
    // 处理玩家
    while(1){
        // 找出结束时间最早的桌子
        temp = 1;
        min = T[1].current_time;
        for(i = 2;i <= k;i++){="" if(t[i].current_time="" <="" min){="" min="T[i].current_time;" temp="i;" }="" 将玩家队列中到达时间比最小结束时间早的玩家加入等待队列="" for(i="start;i" n;i++){="" if(p[i].arrive_time="" ptr="(struct" node="" *)malloc(sizeof(struct="" node));="" ptr-="">index = i;
                ptr->next = NULL;
                rear->next = ptr;
                rear = ptr;
            }
            else
                break;
        }
        start = i;
        // 如果等待队列为空
        if(rear == head){
            // start等于n说明所有玩家已经处理，结束循环
            if(start >= n)
                break;
            // 如果还有玩家没有处理
            flag = 0;
            // 如果下一个玩家是vip
            if(P[start].vip){
                // 先安排序号最小vip桌
                for(i = 1;i <= k;i++){="" if(t[i].vip="" &&="" p[start].arrive_time="">= T[i].current_time){
                        flag = 1;
                        temp = i;
                    }
                }
            }
            // 如果玩家不是vip玩家或者是vip玩家但没有空余vip桌子
            if(flag == 0){
                // 安排序号最小的桌子
                for(i = 1;i <= k;i++){="" if(p[start].arrive_time="">= T[i].current_time){
                        temp = i;
                        break;
                    }
                }
            }
            // 更新玩家信息
            P[start].serve_time = P[start].arrive_time;
            P[start].wait_time = 0;
            // 如果服务时间早于21点，则桌子的服务人数加一
            if(P[start].serve_time < 21 * 3600)
                T[temp].number++;
            // 更新桌子的结束时间
            T[temp].current_time = P[start].arrive_time + P[start].play_time;
            start++;
        }
        // 如果等待队列不为空
        else{
            flag = 0;
            // 如果是vip桌子，则搜索等待队列中是否有vip玩家，如果有，则flag等于1
            if(T[temp].vip == 1){
                ptr = head->next;
                ptr1 = head;
                while(ptr != NULL){
                    if(P[ptr->index].vip == 1){
                        flag = 1;
                        break;
                    }
                    ptr = ptr->next;
                    ptr1 = ptr1->next;
                }
            }
            // 如果是普通桌子
            else{
                ptr = head->next;
                // 先判断第一个等待的玩家是否是vip玩家，如果是，则更新当前桌子的序号为vip桌
                if(P[ptr->index].vip == 1){
                    for(i = 1;i <= k;i++){="" if(t[i].vip="" &&="" p[ptr-="">index].arrive_time >= T[i].current_time){
                            temp = i;
                            break;
                        }
                    }

                }
            }
            // 如果是普通桌子或者是vip桌但等待队列中没有vip玩家
            if(flag == 0){
                ptr1 = head;
                ptr = head->next;
            }
            // 获取玩家序号
            index = ptr->index;
            if(ptr == rear){
                ptr1->next = NULL;
                rear = ptr1;
            }
            else
                ptr1->next = ptr->next;
            free(ptr);
            // 更新玩家和桌子信息
            P[index].serve_time = T[temp].current_time;
            P[index].wait_time = P[index].serve_time - P[index].arrive_time;
            if(P[index].serve_time < 21 * 3600)
                T[temp].number++;
            T[temp].current_time += P[index].play_time;
        }
    }

    // 对所有玩家按服务时间排序
    qsort(P , n , sizeof(struct player) , compare_serve);
    // 输出
    for(i = 0;i < n;i++){
        // 如果服务时间小于21点，则输出
        if(P[i].serve_time < 21 * 3600){
            print_time(P[i].arrive_time);
            print_time(P[i].serve_time);
            // 对等待时间做四舍五入处理
            printf("%d\n" , (int)(P[i].wait_time / 60 + 0.5));
        }
    }
    // 输出桌子的服务人数
    printf("%d" , T[1].number);
    for(i = 2;i <= k;i++)="" printf("="" %d"="" ,="" t[i].number);="" }="" void="" print_time(int="" n){="" int="" hour="" minute="" second;="" 3600;="" n="n" %="" 60;="" second="n;" printf("%02d:%02d:%02d="" "="" second);="" compare_arrive(const="" *a="" const="" *b){="" return="" (*(struct="" player="" *)a).arrive_time="" -="" *)b).arrive_time;="" compare_serve(const="" *)a).serve_time="" *)b).serve_time;="" <="" pre=""></=></=></=></=></=></=></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71025-pat-ranking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71025-pat-ranking/" itemprop="url">PAT甲级1025 PAT Ranking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:36:12+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71025-pat-ranking/" class="leancloud_visitors" data-flag-title="PAT甲级1025 PAT Ranking">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1025 PAT Ranking，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1025" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1025</a><br>解题分析：<br>排序问题。用库函数qsort可以轻松解决。首先在输入一个地区的参加者的信息之后，要对同一地区的参赛者排序，计算出本地排名，然后对所有参赛者排序，计算最终排名。计算排名时注意类似于1 1 3这样的排名。对于成绩相同的参赛者，其排名相同，输出时按注册账号排序。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct record{
    char reg_number[14];
    int score;
    int rank;
    int location_number;
    int local_rank;
};//储存参赛者信息

void rank_local(struct record arr[] , int n);
void rank_total(struct record arr[] , int n);
void output(struct record arr[] , int n);
int compare_score(const void *a , const void *b);
int compare_name(const void *a , const void *b);

int main(){
    int n , k;
    int i , j;
    int count = 1;
    int num = 0;
    char reg_number[14];
    int score;
    struct record list[30000];

    scanf("%d" , &n);
    // 分别输入n个地区的参赛者信息
    for(i = 1;i <= 1="" n;i++){="" scanf("%d"="" ,="" &k);="" 输入k个参赛者的信息="" for(j="0;j" <="" k;j++){="" scanf("%s="" %d"="" list[j="" +="" num].reg_number="" &list[j="" num].score);="" 当前参赛地区编号为count="" num].location_number="count;" }="" 对同一地区参赛者排序="" qsort(list="" num="" k="" sizeof(struct="" record)="" compare_score);="" 计算本地排名="" rank_local(list="" k);="" 地区编号加一="" count++;="" 更新参赛人数="" 对所有参赛者排序="" 计算总排名="" rank_total(list="" num);="" 输出="" output(list="" void="" rank_local(struct="" record="" arr[]="" int="" n){="" i;="" 第一个排名为1="" arr[0].local_rank="1;" 从第二个参赛者开始="" for(i="1;i" 如果当前参赛者的成绩和前一个参赛者成绩不同="" if(arr[i].score="" !="arr[i-1].score)" 本地排名等于i加一="" arr[i].local_rank="i" 1;="" 否则，本地排名于前一个参赛者排名相同="" else="" rank_total(struct="" start="0," end="0;" arr[0].rank="1;" 从第二个开始="" 如果当前参赛者的成绩和之前的参赛者成绩不同="" -="" 1].score){="" 总排名等于i加一="" arr[i].rank="i" 对之前成绩相同的参赛者按注册账号排序="" qsort(arr="" compare_name);="" 重置start，end="" 否则="" else{="" 总排名等于前一个参赛者的排名="" end等于当前参赛者的索引="" output(struct="" printf("%d\n"="" n);="" n;i++)="" printf("%s="" %d="" %d\n"="" arr[i].reg_number="" arr[i].location_number="" arr[i].local_rank);="" compare_score(const="" *a="" const="" *b){="" return="" (*(struct="" *)b).score="" *)a).score;="" compare_name(const="" strcmp((*(struct="" *)a).reg_number="" *)b).reg_number);="" pre=""></=></string.h></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71024-palindromic-number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71024-palindromic-number/" itemprop="url">PAT甲级1024 Palindromic Number</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:34:42+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71024-palindromic-number/" class="leancloud_visitors" data-flag-title="PAT甲级1024 Palindromic Number">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1024 Palindromic Number，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1024" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1024</a><br>解题分析；<br>大整数相加运算。大整数貌似都当作字符串处理会比较简单。首先输入一个整数，存入字符数组。接着判断是否是Palindromic number，如果是，则输出字符串和对应的执行次数，如果不是，则反转字符串，得到另一个字符串，然后两个字符串相加，再次执行相同的步骤。执行次数不能超过k，超过k之后直接输出执行次数为k时的字符串和k。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>

int get_length(char s[]);
int is_parlindromic(char s[] , int length);
void reverse(char s[] , char r[] , int length);
void add(char s[] , char r[] , int length);
int main(){
    char s[100];
    char r[100];
    int k;
    int i;
    int length;

    scanf("%s %d" , s , &k);
    for(i = 0;i <= 1="" k;i++){="" 计算字符串长度="" length="get_length(s);" 如果是palindromic="" number或者执行次数为k="" if(is_parlindromic(s="" ,="" length)="=" ||="" i="=" k){="" 输出字符串和执行次数="" printf("%s\n%d"="" s="" i);="" 返回="" return="" 0;="" }="" 否则="" else{="" 反转字符串，并存入r="" reverse(s="" r="" length);="" 相加，并将结果存入s="" add(s="" int="" get_length(char="" s[]){="" while(s[i]="" !="\0" )="" i++;="" i;="" 判断是否为palindromic="" number="" is_parlindromic(char="" s[]="" length){="" j;="" 从头和尾开始比较，如有不相等的两个数字，则返回0，否则返回1="" for(i="0,j" =="" -="" 1;i="" <="j;i++,j--){" if(s[i]="" 1;="" 反转字符串="" void="" reverse(char="" char="" r[]="" j="0;">= 0;i--)
        r[j++] = s[i];
    r[j] = '\0';
}

// 相加两个字符串
void add(char s[] , char r[] , int length){
    int temp , temp1 , temp2;
    int flag = 0;
    int i , j = 0;
    char sum[100];
    int index = 0;

    // 从最后一位开始计算
    for(i = length - 1;i >= 0;i--){
        // 将字符转化成数字
        temp1 = s[i] - '0';
        temp2 = r[i] - '0';
        // 相加并加上进位
        temp = temp1 + temp2 + flag;
        // 如果结果大于等于10
        if(temp >= 10){
            // 进位
            flag = 1;
            // 结果减去10
            temp -= 10;
        }
        // 否则，无进位
        else    
            flag = 0;
        // 结果转换成字符存入sum
        sum[index++] = temp + '0';
    }
    // 如果有进位
    if(flag == 1)
        // 将字符1存入
        sum[index++] = '1';
    // 将结果放入到s
    for(i = index - 1;i >= 0;i--){
        s[j++] = sum[i];
    }
    s[j] = '\0';
}

</=></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71023-have-fun-with-numbers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71023-have-fun-with-numbers/" itemprop="url">PAT甲级1023 Have Fun with Numbers</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:32:47+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71023-have-fun-with-numbers/" class="leancloud_visitors" data-flag-title="PAT甲级1023 Have Fun with Numbers">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1023 Have Fun with Numbers，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1023" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1023</a><br>解题分析：<br>大整数运算。20位的整数用unsigned long long都无法全部表示出来，因此将大整数当作一个字符串来处理。使用一个check数组纪录每一个数字的使用情况，如果最终每一个数组值都是0，则输出Yes，否则输出No。从字符串最后一位开始处理，先将原值对应的数组值加一，然后乘2并加上进位，如果最后结果大于等于10，则flag等于1，相当于进位，并更新结果值，即减十，再将结果对应的数组值减一。如果最终flag等于1或者check数组内有非0值，则输出No，否则输出Yes，并且如果flag等于1，输出1（进位）。最后输出结果即可。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>

int main(){
    char s[21];
    int flag = 0, flag1 = 0;
    int check[20];
    int i = 0, j;
    int temp;

    scanf("%s" , s);
    // 初始化check
    for(j = 0;j < 20;j++) check[j] = 0;
    // 计算字符串长度
    while(s[i+1] != '\0') i++;
    // 从最后一位开始处理
    for(j = i;j >= 0;j--){
        // 将字符转换成数字
        temp = s[j] - '0';
        // 对应check加一
        check[temp]++;
        // 乘2并加上进位
        temp = temp * 2 + flag;
        // 如果结果大于等于10
        if(temp >= 10){
            // 进位
            flag = 1;
            // 结果减10
            temp -= 10;
        }
        // 否则，无进位
        else
            flag = 0;
        // 结果对应的check减一
        check[temp]--;
        // 将结果转换成字符放入字符串
        s[j] = temp + '0';
    }
    // 检查check是否有非0值
    for(j = 0;j < 20;j++)
        if(check[j] != 0)
            flag1 = 1;
    // 如果check有非0值或有进位，输出No
    if(flag == 1 || flag1 == 1)
        printf("No\n");
    // 否则输出Yes
    else    
        printf("Yes\n");
    // 如果有进位，输出1
    if(flag == 1)
        printf("1");
    // 输出结果
    for(j = 0;j <= i;j++)="" printf("%c"="" ,="" s[j]);="" }="" <="" pre=""></=></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71022-digital-library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71022-digital-library/" itemprop="url">PAT甲级1022 Digital Library</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:30:07+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71022-digital-library/" class="leancloud_visitors" data-flag-title="PAT甲级1022 Digital Library">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1022 Digital Library，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1022" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1022</a><br>解题分析：<br>这题最后一个测试点超时。。。看了自己的程序发现基本没有优化的空间，所以也就放弃了最后一个测试点，可能总体的思路有问题。这个程序的总体思路是把标题、作者等信息分别用不同的数组存储，每当输入一个新的数据块，对于不同的信息在不同的数组搜索，比如作者信息就在储存有所有作者的数组中搜索，如果发现该作者已经存在，则把ID插入，如果作者不存在，则将作者插入，接着把ID插入。其他信息同理，对于关键词就把它拆成几个关键词，然后多次搜索。程序中搜索使用的是二分查找，本以为这样能省下很多时间然而还是超时了。在此只把自己现在的思路说一下，以后可以重新思考以及和大家讨论。查询的话很简单，二分查找之后把对应的ID放到另一个数组中，然后快排，再输出，没找到就输出Not Found。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct node{
    char ID[8];
    struct node *next;
};//储存ID信息
struct record{
    char s[81];
    struct node *ptr;
};//纪录各种信息，包括标题，作者等

int binary_search(struct record arr[] , int start , int end , char s[]);
void insert(struct record arr[] , int index , char s[] , char ID[] , int *end);
void search(struct record arr[] , int start , int end , char query[]);
int compare(const void *a , const void *b);

int main(){
    // 储存不同信息的数组定义
    struct record Title[10000];
    struct record Author[10000];
    struct record Keyword[1000];
    struct record Publisher[1000];
    struct record Pubyear[2001];
    int n , m;
    char ID[8] , title[81] , author[81] , keyword[81] , publisher[81] , pubyear[81];
    int s1 , e1 , s2 , e2 , s3 , e3 , s4 , e4 , s5 , e5;//不同信息的开始和结束索引
    char s[11];
    char query[84];
    int i , j , k , t;
    int index;

    // 索引初始化
    s1 = s2 = s3 = s4 = s5 = 0;
    e1 = e2 = e3 = e4 = e5 = -1;
    scanf("%d" , &n);
    // n个数据块
    for(i = 0;i < n;i++){
        // 输入ID
        scanf("%s" , ID);
        // 消去回车，不然会在接下来输入字符时被作为一个字符读入
        getchar();
        // 输入标题
        j = 0;
        do{
            scanf("%c" , &title[j]);
        }while(title[j++] != '\n');
        title[j - 1] = '\0';
        // 输入作者
        j = 0;
        do{
            scanf("%c" , &author[j]);
        }while(author[j++] != '\n');
        author[j - 1] = '\0';
        // 输入关键词
        j = 0;
        do{
            scanf("%c" , &keyword[j]);
        }while(keyword[j++] != '\n');
        keyword[j - 1] = '\0';
        // 输入出版商
        j = 0;
        do{
            scanf("%c" , &publisher[j]);
        }while(publisher[j++] != '\n');
        publisher[j - 1] = '\0';
        // 输入出版日期
        scanf("%s" , pubyear);
        getchar();
        // 在标题数组查找
        index = binary_search(Title , s1 , e1 , title);
        // 插入ID到标题数组
        insert(Title , index , title , ID , &e1);
        // 快速排序
        if(index == -1 && strcmp(Title[e1].s , Title[e1-1].s) < 0)
            qsort(Title , e1 - s1 + 1 , sizeof(struct record) , compare);
        // 在作者数组中查找
        index = binary_search(Author , s2 , e2 , author);
        // 插入ID到作者数组
        insert(Author , index , author , ID , &e2);
        // 快速排序
        if(index == -1 && strcmp(Author[e2].s , Author[e2-1].s) < 0)
            qsort(Author , e2 - s2 + 1, sizeof(struct record) , compare);
        // 拆分关键词
        for(j = 0 , k = -1;keyword[j] != '\0';j++){
            if(keyword[j] != ' ' && keyword[j+1] != '\0')
                continue;
            if(keyword[j+1] == '\0') j++;
            t = 0;
            for(k++;k < j;k++)
                s[t++] = keyword[k];
            s[t] = '\0';
            k = j;
            // 在关键词数组中查找
            index = binary_search(Keyword , s3 , e3 , s);
            // 插入ID到关键词数组
            insert(Keyword , index , s , ID , &e3);
            // 快速排序
            if(index == -1 && strcmp(Keyword[e3].s , Keyword[e3-1].s) < 0)
                qsort(Keyword , e3 - s3 + 1 , sizeof(struct record) , compare);
        }
        // 在出版商数组查找
        index = binary_search(Publisher , s4 , e4 , publisher);
        // 插入ID到出版商数组
        insert(Publisher , index , publisher , ID , &e4);
        // 快速排序
        if(index == -1 && strcmp(Publisher[e4].s , Publisher[e4-1].s) < 0)
            qsort(Publisher , e4 - s4 + 1 , sizeof(struct record) , compare);
        // 在出版日期数组中查找
        index = binary_search(Pubyear , s5 , e5 , pubyear);
        // 插入ID到出版日期数组
        insert(Pubyear , index , pubyear , ID , &e5);
        // 快速排序
        if(index == -1 && strcmp(Pubyear[e5].s , Pubyear[e5-1].s) < 0)
            qsort(Pubyear , e5 - s5 + 1 , sizeof(struct record) , compare);
    }

    scanf("%d" , &m);
    getchar();
    // m次查询
    for(i = 0;i < m;i++){
        // 输入查询字符串
        j = 0;
        do{
            scanf("%c" , &query[j]);
        }while(query[j++] != '\n');
        query[j - 1] = '\0';
        printf("%s\n" , query);
        // 根据字符串做不同查询
        switch(query[0]){
            case '1':search(Title , s1 , e1 , query + 3);break;
            case '2':search(Author , s2 , e2 , query + 3);break;
            case '3':search(Keyword , s3 , e3 , query + 3);break;
            case '4':search(Publisher , s4 , e4 , query + 3);break;
            case '5':search(Pubyear , s5 , e5 , query + 3);break;
        }
    }
}

// 二分查找
int binary_search(struct record arr[] , int start , int end , char s[]){
    int mid;

    while(start <= end){="" mid="(start" +="" end)="" 2;="" if(strcmp(arr[mid].s="" ,="" s)="" <="" 0)="" start="mid" 1;="" else=""> 0)
            end = mid - 1;
        else
            return mid;
    }

    return -1;
}

// 插入ID
void insert(struct record arr[] , int index , char s[] , char ID[] , int *end){
    struct node *ptr;

    // 新建一个结构块
    ptr = (struct node *)malloc(sizeof(struct node));
    strcpy(ptr->ID , ID);
    // 如果index等于－1，则没有查找到相应的字符串
    if(index == -1){
        // 将相应的字符串插入
        strcpy(arr[++(*end)].s , s);
        // 插入ID
        ptr->next = NULL;
        arr[*end].ptr = ptr;
    }
    // 否则直接插入ID
    else{
        ptr->next = arr[index].ptr;
        arr[index].ptr = ptr;
    }
}

// 查找
void search(struct record arr[] , int start , int end , char query[]){
    int index;
    struct record result[10000];
    struct node *ptr;
    int i = 0 , j;

    // 二分查找获取索引
    index = binary_search(arr , start , end , query);
    // 没有找到则输出Not Found
    if(index == -1)
        printf("Not Found\n");
    // 如果找到
    else{
        // 获取所有ID
        ptr = arr[index].ptr;
        while(ptr != NULL){
            strcpy(result[i++].s , ptr->ID);
            ptr = ptr->next;
        }
        // 排序
        qsort(result , i , sizeof(struct record) , compare);
        // 输出
        for(j = 0;j < i;j++)
            printf("%s\n" , result[j].s);
    }
}

int compare(const void *a , const void *b){
    return strcmp((*(struct record *)a).s , (*(struct record *)b).s);
}
</=></string.h></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/10/pat-e7-94-b2-e7-ba-a71021-deepest-root/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/pat-e7-94-b2-e7-ba-a71021-deepest-root/" itemprop="url">PAT甲级1021 Deepest Root</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T01:25:58+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/10/pat-e7-94-b2-e7-ba-a71021-deepest-root/" class="leancloud_visitors" data-flag-title="PAT甲级1021 Deepest Root">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1021 Deepest Root，原题地址：<br><a href="https://www.patest.cn/contests/pat-a-practise/1021" target="_blank" rel="external">https://www.patest.cn/contests/pat-a-practise/1021</a><br>解题分析：<br>无向图的联通分量的求解以及BFS的应用。由于内存的限制，只能使用邻接链表储存各条边，同时使用一个一维数组E储存所有边。利用边集E和并查集就可以计算出联通分量的个数。然后再以任一个节点为根节点，宽度搜索遍历整张图，计算高度。所有节点都依次作为根节点，有最大高度的节点储存在stack里，最后输出即可。</p>
<pre lang="c" line="1" escaped="true">
#include<stdio.h>
#include<stdlib.h>

#define Max 10001
#define INFINITY 100000
struct node{
    int index;
    struct node *next;
};//邻接链表的节点
struct edge{
    int start;
    int end;
};//边集中的一条边

void connect(struct node *G[] , int s1 , int s2);
int find_components(struct edge E[] , int n);
int find(int *union_find , int n);
int get_height(struct node *G[] , int v , int n);

int main(){
    struct node *G[Max];
    struct edge E[Max];
    int stack[Max];
    int top = -1;
    int max = -INFINITY;
    int n;
    int k;
    int s1 , s2;
    int i , j;
    int height;

    scanf("%d" , &n);
    // 初始化
    for(i = 1;i <= n;i++)="" g[i]="NULL;" for(i="0;i" <="" n="" -="" 1;i++){="" scanf("%d="" %d"="" ,="" &s1="" &s2);="" 连接两个点="" connect(g="" s1="" s2);="" s2="" s1);="" 将边存入边集="" e[i].start="s1;" e[i].end="s2;" }="" 计算联通分量个数="" k="find_components(E" n);="" 如果不为1，则输出error="" if(k="" !="1){" printf("error:="" %d="" components"="" k);="" return="" 0;="" 遍历所有节点，每次都以一个节点作为根节点="" 计算高度="" height="get_height(G" i="" 如果高度比之前的高度大="" if(height=""> max){
            // 更新最大高度
            max = height;
            // 清空stack，并将当前点放入
            top = -1;
            stack[++top] = i;
        }
        // 如果高度与最大高度相等，则直接放入stack
        else if(height == max){
            stack[++top] = i;
        }
    }
    // 输出
    for(i = 0;i <= top;i++)="" printf("%d\n"="" ,="" stack[i]);="" }="" 连接两点="" void="" connect(struct="" node="" *g[]="" int="" s1="" s2){="" struct="" *ptr;="" ptr="(struct" node*)malloc(sizeof(struct="" node));="" ptr-="">index = s2;
    ptr->next = G[s1];
    G[s1] = ptr;
}

// 计算联通分量个数
int find_components(struct edge E[] , int n){
    int *union_find;
    int i;
    int k = 0;
    int ancestor1 , ancestor2;

    // 建立并查集
    union_find = (int *)malloc(sizeof(int) * (n + 1));
    // 初始化并查集
    for(i = 1;i <= n;i++)="" union_find[i]="-1;" 遍历边集="" for(i="0;i" <="" n="" -="" 1;i++){="" 查找两个端点的祖先="" ancestor1="find(union_find" ,="" e[i].start);="" ancestor2="find(union_find" e[i].end);="" 如果两个端点的祖先不相等="" if(ancestor1="" !="ancestor2)" 合并="" union_find[ancestor1]="ancestor2;" }="" 计算联通分量个数="" if(union_find[i]="=" -1)="" k++;="" return="" k;="" 在并查集中查找祖先，并且压缩路径="" int="" find(int="" *union_find="" n){="" if(union_find[n]="" union_find[n]="find(union_find" union_find[n]);="" n;="" 计算高度="" get_height(struct="" node="" *g[]="" v="" queue[max];="" front="0" rear="-1;" i;="" count;="" visited[max];="" height="0;" struct="" *ptr;="" visited[i]="0;" 将根节点放入队列="" queue[++rear]="v;" while(1){="" 计算每一层的节点个数="" count="rear" +="" 1;="" 如果节点个数不是正数，则遍历结束="" if(count="" break;="" 高度加一="" height++;="" 遍历当前层的所有节点="" while(count--=""> 0){
            // 出队
            k = queue[front++];
            // 设置为已访问
            visited[k] = 1;
            // 访问相邻的节点
            ptr = G[k];
            while(ptr != NULL){
                // 如果相邻的节点未被访问
                if(visited[ptr->index] == 0)
                    // 入队
                    queue[++rear] = ptr->index;
                ptr = ptr->next;
            }
        }
    }
    // 返回
    return height;
}
</=></=></=></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/head_pic.jpg"
               alt="hys" />
          <p class="site-author-name" itemprop="name">hys</p>
           
              <p class="site-description motion-element" itemprop="description">ZJU SE</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">140</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hys</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("5D36qMqpdGWPR54lVQXrLK3i-gzGzoHsz", "QDWhA0MlABzitDoWhh9zgMQh");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
