<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="ZJU SE">
<meta property="og:type" content="website">
<meta property="og:title" content="hys&#39;s blog">
<meta property="og:url" content="https://ShengAndXian.github.io/page/8/index.html">
<meta property="og:site_name" content="hys&#39;s blog">
<meta property="og:description" content="ZJU SE">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hys&#39;s blog">
<meta name="twitter:description" content="ZJU SE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ShengAndXian.github.io/page/8/"/>





  <title>hys's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hys's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习中的点滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/21/pat-e7-94-b2-e7-ba-a71067-sort-with-swap0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/21/pat-e7-94-b2-e7-ba-a71067-sort-with-swap0/" itemprop="url">PAT甲级1067 Sort with Swap(0,*)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-21T07:24:46+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1067 Sort with Swap(0,*)，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1067</a><br>解题分析：<br>建立一个数组，arr[i]＝j表示数i在j位置，交换两数其实就是交换两数的位置，也就是说交换i和j就是交换arr[i]和arr[j]。每次都从数字0开始，如果0不在0位置，那么它一定占了别的数字的位置，把对应的数字和0交换，该数字归位，0移动到对应位置，然后继续执行此步骤，直到0回到0的位置。然后遍历数组，查找还没有归位的数，将其和0交换，接着继续执行上面的步骤，如果全部数字都归位了就输出交换次数，程序结束。需要注意的是，每次查找没有归位的数都需从上一次查找结束的点开始，否则会超时。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>
#include<stdlib.h>

int main(){
    long n;
    long i;
    long *arr;
    long num;
    long ans = 0;
    long temp;
    long k = 0;

    scanf(\"%ld\" , &n);
    arr = (long *)malloc(sizeof(long) * n);
    for(i = 0;i < n;i++){
        scanf(\"%ld\" , &num);
        arr[num] = i;
    }
    while(1){
        // 0不在0位置
        while(arr[0] != 0){
            // 交换
            temp = arr[arr[0]];
            arr[arr[0]] = arr[0];
            arr[0] = temp;
            ans++;
        }
        // 从上一次查找结束点开始查找没有归位的数
        for(i = k;i < n;i++)
            if(arr[i] != i){
                k = i;
                break;
            }
        // 全部数都归位了
        if(i == n)
            break;
        // 交换
        arr[0] = arr[i];
        arr[i] = 0;
        ans++;
    }
    printf(\"%ldn\" , ans);
}
</stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/21/pat-e7-94-b2-e7-ba-a71066-root-of-avl-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/21/pat-e7-94-b2-e7-ba-a71066-root-of-avl-tree/" itemprop="url">PAT甲级1066 Root of AVL Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-21T07:23:29+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1066 Root of AVL Tree，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1066</a><br>解题分析：<br>AVL树的插入。AVL树也是一种二叉搜索树，插入时按照二叉搜索树的插入方法插入，在返回时判断是否平衡，如果不平衡，通过旋转调整子树至平衡状态。(由于某些原因，这道题不能上代码，不过关于AVL树的讲解网上有很多)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/20/pat-e7-94-b2-e7-ba-a71065-ab-and-c-64bit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/20/pat-e7-94-b2-e7-ba-a71065-ab-and-c-64bit/" itemprop="url">PAT甲级1065 A+B and C (64bit)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-20T12:27:58+08:00">
                2017-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1065 A+B and C (64bit)，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1065</a><br>解题分析：<br>利用溢出解决问题。如果两个数一个为正数，一个为负数，则两数相加一定不会溢出。如果两个数均为正数，则可能产生溢出，溢出后的值在区间[-2^63 , -2]内。如果两数均为负值，则也可能产生溢出，溢出后的值的范围在区间[0 , 2^63 - 1]。正数相加溢出，说明结果一定比c大，负数相加溢出，说明结果一定比c小。如果不溢出，则直接判断大小。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>

int main(){
    long long a , b , c;
    long long sum;
    int t , i;

    scanf(\"%d\" , &t);
    for(i = 1;i <= t;i++){="" scanf(\"%lld%lld%lld\"="" ,="" &a="" &b="" &c);="" printf(\"case="" #%d:="" \"="" i);="" sum="a" +="" b;="" 一正一负="" if((a=""> 0 && b < 0) || (a < 0 && b > 0)){
            if(sum > c)
                printf(\"truen\");
            else
                printf(\"falsen\");
        }
        // 两个正数
        else if(a > 0 && b > 0){
            // 判断溢出
            if(sum < 0)
                printf(\"truen\");
            else if(sum > c)
                printf(\"truen\");
            else
                printf(\"falsen\");
        }
        // 两个负数
        else if(a < 0 && b < 0){
            // 判断溢出，注意负数相加溢出后可以取到0
            if(sum >= 0)
                printf(\"falsen\");
            else if(sum > c)
                printf(\"truen\");
            else
                printf(\"falsen\");
        }
        // 有一数为0
        else{
            if(sum > c)
                printf(\"truen\");
            else
                printf(\"falsen\");
        }
    }
}
</=></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/20/pat-e7-94-b2-e7-ba-a71064-complete-binary-search-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/20/pat-e7-94-b2-e7-ba-a71064-complete-binary-search-tree/" itemprop="url">PAT甲级1064 Complete Binary Search Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-20T12:26:43+08:00">
                2017-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1064 Complete Binary Search Tree，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1064</a><br>解题分析：<br>完全二叉搜索树。先对输入的序列从小到大排序，由于是完全二叉树，因此可以根据节点的总数计算出左子树所有节点的数量，当前树的根节点就是排在这些节点后的第一个节点（根据二叉搜索树的性质），因此就可以得到根节点的索引，递归求得左子树和右子树的根节点的索引，把它们储存起来，递归完整棵树之后，宽度优先搜索输出树的层序遍历序列。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

struct node{
    int key;
    int left;
    int right;
};//储存节点信息

int cmp(const void *a , const void *b);
int Construct(struct node T[] , int start , int end);

int main(){
    struct node T[1000];
    int n;
    int root;
    int i;
    int queue[1000];
    int front = 0 , rear = -1;
    int temp;
    int flag = 1;

    scanf(\"%d\" , &n);
    for(i = 0;i < n;i++)
        scanf(\"%d\" , &T[i].key);
    // 排序
    qsort(T , n , sizeof(struct node) , cmp);
    // 获取根节点的索引
    root = Construct(T , 0 , n - 1);
    // 层序遍历
    queue[++rear] = root;
    while(front <= rear){="" temp="queue[front++];" if(flag){="" printf(\"%d\"="" ,="" t[temp].key);="" flag="0;" }="" else{="" printf(\"="" %d\"="" if(t[temp].left="" !="-1)" queue[++rear]="T[temp].left;" if(t[temp].right="" printf(\"n\");="" return="" 0;="" int="" construct(struct="" node="" t[]="" start="" end){="" cnt="end" -="" +="" 1;="" h;="" left;="" i;="" root;="" start大于end直接返回－1="" if(start=""> end)
        return -1;
    // 计算树的高度，起始高度设为1
    for(h = 1;pow(2 , h) - 1 < cnt;h++) ;
    // 如果树的高度为1，则是叶子节点
    if(h == 1){
        T[start].left = -1;
        T[end].right = -1;
        return start;
    }
    // 计算左子树节点数量
    left = pow(2 , h - 2) - 1;
    if(cnt - 2 * left - 1 > pow(2 , h - 2))
        left += pow(2 , h - 2);
    else
        left += cnt - 2 * left - 1;
    // 根节点排在左子树所有节点后面
    root = start + left;
    // 递归获取左子树和右子树的根节点
    T[root].left = Construct(T , start , root - 1);
    T[root].right = Construct(T , root + 1 , end);
    return root;
}

int cmp(const void *a , const void *b){
    return (*(struct node *)a).key - (*(struct node *)b).key;
}
</=></math.h></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/19/pat-e7-94-b2-e7-ba-a71063-set-similarity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/19/pat-e7-94-b2-e7-ba-a71063-set-similarity/" itemprop="url">PAT甲级1063 Set Similarity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-19T10:18:21+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1063 Set Similarity，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1063</a><br>解题地址：<br>计算两个集合的相似度。同一个集合内，所有相同的数都看作只有一个这样的数，计算所有不同的数的个数时，两个集合每两个相同的数都算一个，其他不同的数就依次统计即可，计算相同的数的个数只需依次统计即可。在统计前，需要对集合进行排序，然后从下标0开始，如果一个集合的数比另一个集合小，则该集合的下标加一，纪录不同数的个数的变量dist加一，如果两个集合的数相等，则两个集合的下标均加一，dist加一，纪录相同数的个数的变量com也加一。最后计算输出即可。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>
#include<stdlib.h>

struct record{
    int cnt;
    long arr[10000];
};

int cmp(const void *a , const void *b){
    return (*(long *)a) - (*(long *)b);
}

int main(){
    struct record R[51];
    int n , m , k;
    long num;
    int i , j;
    int com , dist;
    int s1 , e1 , s2 , e2 , prev1 , prev2;
    int set1 , set2;
    int flag;

    scanf(\"%d\" , &n);
    for(i = 1;i <= n;i++){="" scanf(\"%d\"="" ,="" &m);="" r[i].cnt="0;" for(j="0;j" <="" m;j++){="" scanf(\"%ld\"="" &num);="" r[i].arr[r[i].cnt++]="num;" }="" 排序="" qsort(r[i].arr="" sizeof(long)="" cmp);="" &k);="" for(i="0;i" k;i++){="" scanf(\"%d%d\"="" &set1="" &set2);="" 初始化="" s1="s2" =="" 0;="" prev1="prev2" -1;="" com="dist" while(1){="" 循环结束条件="" if(s1="=" r[set1].cnt="" ||="" s2="=" r[set2].cnt)="" break;="" 如果集合1的下标移动了="" !="prev1){" 重新计算含有相同值的区间，e1为区间右边界="" for(e1="s1" +="" 1;e1="" r[set1].cnt;e1++)="" if(r[set1].arr[e1]="" e1--;="" 如果集合2的下标移动了="" if(s2="" 重新计算含有相同值的区间="" for(e2="s2" 1;e2="" r[set2].cnt;e2++)="" if(r[set2].arr[e2]="" e2--;="" 纪录当前的下标，用于判断下标是否移动，防止重复计算含有相同值的区间="" prev2="s2;" 如果两个集合的值相等="" if(r[set1].arr[s1]="=" r[set2].arr[s2]){="" 下标移动到下一个不相等的值处="" 1;="" 相应变量更新="" com++;="" dist++;="" 如果集合1的值大于集合2的值="" else=""> R[set2].arr[s2]){
                // 更新集合2的下标
                s2 = e2 + 1;
                // dist加一
                dist++;
            }
            // 类似情况
            else{
                s1 = e1 + 1;
                dist++;
            }
        }
        // 如果集合2有剩余的数未和集合1比较
        if(s1 == R[set1].cnt && s2 != R[set2].cnt){
            flag = 1;
            for(e2 = s2;e2 < R[set2].cnt;e2++){
                if(e2 == s2){
                    if(flag){
                        flag = 0;
                        dist++;
                    }
                }
                else{
                    dist++;
                    s2 = e2;
                }
            }
        }
        // 如果集合1有剩余的数未和集合2比较
        if(s1 != R[set1].cnt && s2 == R[set2].cnt){
            flag = 1;
            for(e1 = s1;e1 < R[set1].cnt;e1++){
                if(e1 == s1){
                    if(flag){
                        flag = 0;
                        dist++;
                    }
                }
                else{
                    dist++;
                    s1 = e1;
                }
            }
        }
        // 输出
        printf(\"%.1f%%n\" , (float)com / dist * 100);
    }
}
</=></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/19/pat-e7-94-b2-e7-ba-a71062-talent-and-virtue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/19/pat-e7-94-b2-e7-ba-a71062-talent-and-virtue/" itemprop="url">PAT甲级1062 Talent and Virtue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-19T10:16:32+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1062 Talent and Virtue，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1062</a><br>解题分析：<br>排序题。这题重点就在于qsort的比较函数，比较的流程如下：<br>1、判断是否有一个为圣人，如果有，接着判断是否两个都是，如果都是则根据排序规则排序，如果不是，则圣人排在非圣人前面<br>2、如果两个都不是圣人，判断是否一个为君子，如果有，接着判断两个是否都是，如果都是则根据排序规则排序，如果不是，则君子排在非君子之前<br>3、如果两者都不是圣人、君子，则判断是否有一个为小人，如果有，则接着判断是否两个都是，如果都是则根据排序规则排序，如果不是，则非小人排在小人前面<br>4、如果都不满足前面的条件，则两人都是愚人，直接按照排序规则排序<br>最后输出即可。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct record{
    char id[9];
    long virtue;
    long talent;
};

int cmp(const void *a ,const void *b);

long n , l , h;

int main(){
    long i;
    long cnt = 0;
    char id[9];
    long virtue;
    long talent;
    struct record *R;

    scanf(\"%ld%ld%ld\" , &n , &l , &h);
    R = (struct record *)malloc(sizeof(struct record) * n);
    for(i = 0;i < n;i++){
        scanf(\"%s%ld%ld\" , id , &virtue , &talent);
        // 输入时，talent和virtue都在l之下的直接忽略
        if(virtue >= l && talent >= l){
            R[cnt].virtue = virtue;
            R[cnt].talent = talent;
            strcpy(R[cnt].id , id);
            cnt++;
        }
    }
    // 排序
    qsort(R , cnt , sizeof(struct record) , cmp);
    // 输出
    printf(\"%ldn\" , cnt);
    for(i = 0;i < cnt;i++)
        printf(\"%s %ld %ldn\" , R[i].id , R[i].virtue , R[i].talent);
}

int cmp(const void *a , const void *b){
    struct record m , n;
    long sum1 , sum2;
    m = (*(struct record *)a);
    n = (*(struct record *)b);
    sum1 = m.virtue + m.talent;
    sum2 = n.virtue + n.talent;
    // 两个之间至少有一个为圣人
    if((m.virtue >= h && m.talent >= h) || (n.virtue >= h && n.talent >= h)){
        // 两者都是圣人
        if((m.virtue >= h && m.talent >= h) && (n.virtue >= h && n.talent >= h)){
            // 和不同
            if(sum1 != sum2)
                return sum2 - sum1;
            // 和相同，virtue不同
            else if(m.virtue != n.virtue)
                return n.virtue - m.virtue;
            // 和相同，virtue相同
            else 
                return strcmp(m.id , n.id);
        }
        // m为圣人
        else if(m.virtue >= h && m.talent >= h)
            return -1;
        // n为圣人
        else
            return 1;
    }
    // 两者之间至少有一个为君子
    else if(m.virtue >= h || n.virtue >= h){
        // 两者都是君子
        if(m.virtue >= h && n.virtue >= h){
            if(sum1 != sum2)
                return sum2 - sum1;
            else if(m.virtue != n.virtue)
                return n.virtue - m.virtue;
            else    
                return strcmp(m.id , n.id);
        }
        // m为君子
        else if(m.virtue >= h)
            return -1;
        // n为君子
        else
            return 1;
    }
    // 两者之间至少有一个为小人
    else if(m.talent > m.virtue || n.talent > n.virtue){
        // 两者都是小人
        if(m.talent > m.virtue && n.talent > n.virtue){
            if(sum1 != sum2)
                return sum2 - sum1;
            else if(m.virtue != n.virtue)
                return n.virtue - m.virtue;
            else
                return strcmp(m.id , n.id);
        }
        // m为小人
        else if(m.talent > m.virtue)
            return 1;
        // n为小人
        else
            return -1;
    }
    // 两者都是愚人
    else{
        if(sum1 != sum2)
            return sum2 - sum1;
        else if(m.virtue != n.virtue)
            return n.virtue - m.virtue;
        else    
            return strcmp(m.id , n.id);
    }
}
</string.h></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/19/pat-e7-94-b2-e7-ba-a71061-dating/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/19/pat-e7-94-b2-e7-ba-a71061-dating/" itemprop="url">PAT甲级1061 Dating</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-19T10:15:01+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1061 Dating，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1061</a><br>解题分析：<br>破解福尔摩斯码，前两个字符串要先找到第一个相同的大写字母并且大写字母要在A到G的范围内，找到之后再从这个位置开始向后找两个相同的字母或数字，范围在0到9或A到N之间。第三个和第四个字符串要找到相同的字母，并记录它的位置。都找到后输出即可。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

int main(){
    char s1[65] , s2[65] , s3[65] , s4[65];
    int i , j;
    int day , hour , minute;
    char date[7][4] = {\"MON\" , \"TUE\" , \"WED\" , \"THU\" , \"FRI\" , \"SAT\" , \"SUN\"};

    scanf(\"%s%s%s%s\" , s1 , s2 , s3 , s4);
    // 查找第一个相同的大写字母
    for(i = 0;s1[i] != \'\0\' && s2[i] != \'\0\';i++){
        if(s1[i] == s2[i]){
            // 大写字母要在A到G之内，否则也不能算
            if(s1[i] >= \'A\' && s1[i] <= \'g\')="" break;="" }="" 减去a之后得到的值是在数组date内的索引="" day="s1[i]" -="" \'a\';="" 查找小时="" for(j="i+1;s1[j]" !="\'\0\'" &&="" s2[j]="" if(s1[j]="=" s2[j]){="" 数字="">= \'0\' && s1[j] <= \'9\')="" hour="s1[j]" -="" \'0\';="" 大写字母要在a到n内="" else="" if(s1[j]="">= \'A\' && s1[j] <= \'n\')="" hour="s1[j]" -="" \'a\'="" +="" 10;="" else="" continue;="" break;="" }="" 查找第三个字符串和第四个字符串中相同的字母="" for(i="0;s3[i]" !="\'\0\'" &&="" s4[i]="" if(s3[i]="=" s4[i]){="">= \'a\' && s3[i] <= \'z\')="" break;="" else="" if(s3[i]="">= \'A\' && s3[i] <= \'z\')="" break;="" }="" 记录位置="" minute="i;" printf(\"%s="" %02d:%02dn\"="" ,="" date[day]="" hour="" minute);="" <="" pre=""></=></=></=></=></=></stdlib.h></string.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/18/pat-e7-94-b2-e7-ba-a71060-are-they-equal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/18/pat-e7-94-b2-e7-ba-a71060-are-they-equal/" itemprop="url">PAT甲级1060 Are They Equal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-18T09:13:29+08:00">
                2017-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PAT甲级/" itemprop="url" rel="index">
                    <span itemprop="name">PAT甲级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT甲级1060 Are They Equal，原题地址：<br><a href="\">https://www.patest.cn/contests/pat-a-practise/1060</a><br>解题分析：<br>有些繁琐的题目。首先，计算小数标准形式的指数时，有三种情况：<br>1、指数为正数，比如12.345<br>2、指数为负数，比如0.001<br>3、指数为0，比如0.000。<br>比较两个小数时，先比较它们的指数是否相等，如果不等，那两个截断后的两个小数也一定不等，如果相等，则有三种情况：<br>1、n比两个小数的位数都小，这种情况下，只要前n位数字相等，那截断后的两数相等<br>2、n比两个小数的位数都大，且两个小数位数相等，则只要每一位数字都相等，截断后的两数相等<br>3、两个小数位数不相等，n比较小位数大，这种情况下，不仅需要判断每一位数字是否相等，而且需要判断较长位数的小数在区间［较小位数，n（或较长位数）］内是否全为0，如果全为0，则截断后的两数相等，否则不相等。<br>最后按格式输出即可。</p>
<pre lang="\"c\"" line="\"1\"" escaped="\"true\"">
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int GetCnt(char f[]);
int IsEuqal(char f1[] , char f2[] , int n);
void Output(char f[] , int n);

int main(){
    int n;
    char f1[11000] , f2[11000];

    scanf(\"%d%s%s\" , &n , f1 , f2);
    if(IsEuqal(f1 , f2 , n)){
        printf(\"YES \");
        Output(f1 , n);
        printf(\"n\");
    }
    else{
        printf(\"NO \");
        Output(f1 , n);
        printf(\" \");
        Output(f2 , n);
        printf(\"n\");
    }
}

// 计算指数
int GetCnt(char f[]){
    int i , j;
    int cnt;

    // 获取小数点下标
    for(i = 0;f[i] != \'\0\';i++)
        if(f[i] == \'.\')
            break;
    // 获取第一个数字的下标
    for(j = 0;f[j] == \'0\' || f[j] == \'.\';j++) ;
    // 全部为0
    if(f[j] == \'\0\')
        return 0;
    // 形如0.1,0.01
    if(i < j)
        return i - j + 1;
    // 形如1.0,10.0
    else
        return i - j;
}

// 判断两数阶段后是否相等
int IsEuqal(char f1[] , char f2[] , int n){
    int p , q;
    int cnt = 0;
    int cnt1 , cnt2;
    int i;

    // 获取两数的指数
    cnt1 = GetCnt(f1);
    cnt2 = GetCnt(f2);
    // 如果两数的指数相等
    if(cnt1 != cnt2)
        return 0;
    // 从第一个数字开始
    for(p = 0;f1[p] == \'0\' || f1[p] == \'.\';p++) ;
    for(q = 0;f2[q] == \'0\' || f2[q] == \'.\';q++) ;
    for(;cnt < n && f1[p] != \'\0\' && f2[q] != \'\0\';p++,q++,cnt++){
        // 小数点跳过
        if(f1[p] == \'.\'){
            // cnt记录已经比较的位数
            cnt--;
            continue;
        }
        // 不相等返回0
        if(f1[p] != f2[q])
            return 0;
    }
    // 如果小数位数均小于n
    if(cnt == n)
        return 1;
    // 如果小数位数大于n，但两数一样长
    else if(f1[p] == \'\0\' && f2[q] == \'\0\')
        return 1;
    // 否则
    else{
        // 如果第一个小数较短
        if(f1[p] == \'\0\'){
            // 判断第二个小数
            for(i = p;i < p + n - cnt && f2[i] != \'\0\';i++)
                // 有不为0的位则返回0
                if(f2[i] != \'0\')
                    return 0;
            return 1;
        }
        // 如果第二个小数较短
        else{
            for(i = q;i < q + n - cnt && f2[i] != \'\0\';i++)
                if(f1[i] != \'0\')
                    return 0;
            return 1;
        }
    }
}

// 输出
void Output(char f[] , int n){
    int i;
    int cnt;
    int temp;

    for(i = 0;f[i] == \'0\' || f[i] == \'.\';i++) ;
    printf(\"0.\");
    for(temp = 0;temp < n && f[i] != \'\0\';i++,temp++){
        if(f[i] == \'.\'){
            temp--;
            continue;
        }
        printf(\"%c\" , f[i]);
    }
    if(temp < n)
        for(i = 0;i < n - temp;i++)
            printf(\"0\");
    cnt = GetCnt(f);
    printf(\"*10^%d\" , cnt);
}
</string.h></stdlib.h></stdio.h></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/17/e7-ae-97-e6-9c-af-e5-9f-ba-e6-9c-ac-e5-ae-9a-e7-90-86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/e7-ae-97-e6-9c-af-e5-9f-ba-e6-9c-ac-e5-ae-9a-e7-90-86/" itemprop="url">算术基本定理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-17T13:01:24+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂记/" itemprop="url" rel="index">
                    <span itemprop="name">杂记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>碰到这样一道题，给定一个正整数，把它分解成质数相乘的形式，比如12=2_2_3。解题时没什么思路，就去网上查资料，然后就发现了算术基本定理，在此记录一下。<br><strong>算术基本定理</strong>，又称为<strong>正整数的唯一分解定理</strong>，即：每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。<br>由这个定理，对于一个正整数n，任何能整除它的数都是质数，因此在编程时，用一个变量i，i从2开始，一旦i能整除n，则i就是给定的数的质因数，之后的n等于n / i，再判断能否被i整除，往复循环，直到不能整除时跳出，i加一，继续执行。可以这样证明，如果能整除n的i不是一个质数，那么根据算术基本定理，i一定可以表示成质数的积的形式，既然i能够整除n，那么i的质因子也一定能整除n，即n能被i的质因子整除，而i的每个质因子一定比i小，当i从2一直加到当前i的某个质因子时，n已经被该质因子整除到不能再整除了，因此，当执行到当前i时，n不能被i的任何质因子整除，和之前的假设矛盾，所以，证明了i一定是质数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://ShengAndXian.github.io/2017/02/17/e6-a0-91-e7-8a-b6-e6-95-b0-e7-bb-84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head_pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hys's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/e6-a0-91-e7-8a-b6-e6-95-b0-e7-bb-84/" itemprop="url">树状数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-17T12:27:55+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转载声明<br>  作者：Hawstein<br>  出处：<a href="http://www.hawstein.com/posts/binary-indexed-trees.html" target="_blank" rel="external">http://www.hawstein.com/posts/binary-indexed-trees.html</a><br>  声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译自TopCoder上的一篇文章： Binary Indexed Trees ，并非严格逐字逐句翻译，其中加入了自己的一些理解。水平有限，还望指摘。(此文章含有较多图片，如果有显示不出可以尝试刷新一下)</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>简介</li>
<li>符号含义</li>
<li>基本思想</li>
<li>分离出最后的1</li>
<li>读取累积频率</li>
<li>改变某个位置的频率并且更新数组</li>
<li>读取某个位置的实际频率</li>
<li>缩放整个数状数组</li>
<li>返回指定累积频率的索引</li>
<li>2D BIT(Binary Indexed Trees)</li>
<li>问题样例</li>
<li>总结</li>
<li>参考资料</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们常常需要某种特定的数据结构来使我们的算法更快，于是乎这篇文章诞生了。 在这篇文章中，我们将讨论一种有用的数据结构：数状数组(Binary Indexed Trees)。 按 Peter M. Fenwich (链接是他的论文，TopCoder上的链接已坏)的说法，这种结构最早是用于数据压缩的。 现在它常常被用于存储频率及操作累积频率表。</p>
<p>定义问题如下：我们有n个盒子，可能的操作为：</p>
<ol>
<li>往第i个盒子增加石子(对应下文的update函数)</li>
<li>计算第k个盒子到第l个盒子的石子数量(包含第k个和第l个)<br>原始的解决方案中(即用普通的数组进行存储，box[i]存储第i个盒子装的石子数)， 操作1和操作2的时间复杂度分别是O(1)和O(n)。假如我们进行m次操作，最坏情况下， 即全为第2种操作，时间复杂度为O(n*m)。使用某些数据结构(如 RMQ) ，最坏情况下的时间复杂度仅为O(m log n)，比使用普通数组为快许多。 另一种方法是使用数状数组，它在最坏情况下的时间复杂度也为O(m log n)，但比起RMQ， 它更容易编程实现，并且所需内存空间更少。</li>
</ol>
<h2 id="符号含义"><a href="#符号含义" class="headerlink" title="符号含义"></a>符号含义</h2><ul>
<li>BIT: 树状数组</li>
<li>MaxVal: 具有非0频率值的数组最大索引，其实就是问题规模或数组大小n</li>
<li>f[i]: 索引为i的频率值，即原始数组中第i个值。i=1…MaxVal</li>
<li>c[i]: 索引为i的累积频率值，c[i]=f[1]+f[2]+…+f[i]</li>
<li>tree[i]: 索引为i的BIT值(下文会介绍它的定义)</li>
<li>num^- : 整数num的补，即在num的二进制表示中，0换为1，1换成0。如：num=10101，则 num^- =01010</li>
</ul>
<p>注意: 一般情况下，我们令f[0]=c[0]=tree[0]=0，所以各数组的索引都从１开始。 这样会给编程带来许多方便。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>每个整数都能表示为一些2的幂次方的和，比如13，其二进制表示为1101，所以它能表示为： 13 = 2^0 + 2^2 + 2^3 .类似的，累积频率可表示为其子集合之和。在本文的例子中， 每个子集合包含一些连续的频率值，各子集合间交集为空。比如累积频率c[13]= f[1]+f[2]+…+f[13]，可表示为三个子集合之和(数字3是随便举例的， 下面的划分也是随便举例的)，c[13]=s1+s2+s3， 其中s1=f[1]+f[2]+…+f[4]，s2=f[5]+f[6]+…+f[12]，s3=f[13]。</p>
<p>idx记为BIT的索引，r记为idx的二进制表示中最右边的1后面0的个数， 比如idx=1100(即十进制的12)，那么r=2。tree[idx]记为f数组中， 索引从(idx-2^r +1)到idx的所有数的和，包含f[idx-2^r +1]和f[idx]。即： tree[idx]=f[idx-2^r +1]+…+f[idx]，见表1.1和1.2，你就会一目了然。 我们也可称idx对索引(idx-2^r +1)到索引idx负责。(We also write that idx is responsible for indexes from (idx-2^r +1)to idx)</p>
<p><img src="http://olrdynjoh.bkt.clouddn.com/1.1.png" alt=""><br><img src="http://olrdynjoh.bkt.clouddn.com/1.2.png" alt=""><br><img src="http://olrdynjoh.bkt.clouddn.com/1.3.png" alt=""><br><img src="http://olrdynjoh.bkt.clouddn.com/1.4.png" alt=""></p>
<p>假设我们要得到索引为13的累积频率(即c[13])，在二进制表示中，13=1101。因此， 我们可以这样计算：c[1101]=tree[1101]+tree[1100]+tree[1000]，后面将详细讲解。</p>
<h2 id="分离出最后的1"><a href="#分离出最后的1" class="headerlink" title="分离出最后的1"></a>分离出最后的1</h2><p>注意: 最后的1表示一个整数的二进制表示中，从左向右数最后的那个1。</p>
<p>由于我们经常需要将一个二进制数的最后的1提取出来，因此采用一种高效的方式来做这件 事是十分有必要的。令num是我们要操作的整数。在二进制表示中，num可以记为a1b, a代表最后的1前面的二进制数码，由于a1b中的1代表的是从左向右的最后一个1， 因此b全为0，当然b也可以不存在。比如说13=1101，这里最后的1右边没有0，所以b不存在。</p>
<p>我们知道，对一个数取负等价于对该数的二进制表示取反加1。所以-num等于(a1b)^- +1= a^- 0b^- +1。由于b全是0，所以b^- 全为1。最后，我们得到：</p>
<p>-num=(a1b)^- +1=a^- 0b^- +1=a^- 0(1…1)+1=a^- 1(0…0)=a^- 1b</p>
<p>现在，我们可以通过与操作(在C++,java中符号为&amp;)将num中最后的1分离出来：</p>
<p>num &amp; -num = a1b &amp; a^- 1b = (0…0)1(0…0)</p>
<h2 id="读取累积频率"><a href="#读取累积频率" class="headerlink" title="读取累积频率"></a>读取累积频率</h2><p>给定索引idx，如果我们想获取累积频率即c[idx]，我们只需初始化sum=0, 然后当idx&gt;0时，重复以下操作：sum加上tree[idx], 然后将idx最后的1去掉。 (C++代码如下)</p>
<p><img src="http://olrdynjoh.bkt.clouddn.com/readcf.png" alt=""></p>
<p>为什么可以这么做呢？关键是tree数组设计得好。我们知道，tree数组是这么定义的： tree[idx] = f[idx-2^r +1] +…+ f[idx]. 上面的程序sum加上tree[idx]后， 去掉idx最后的1，假设变为idx1，那么有idx1 = idx-2^r ,　sum接下来加上tree[idx1] = f[idx1-2^r1 +1] +…+ f[idx1] = f[idx1-2^r1 +1] +…+ f[idx-2^r ]， 我们可以看到tree[idx1]表达示的最右元素为f[idx-2^r ]，这与tree[idx]表达式的最左元 素f[idx-2^r +1]无缝地连接了起来。所以，只需要这样操作下去，即可求得f[1]+…+ f[idx]，即c[idx]的结果。</p>
<p>来看一个具体的例子，当idx=13时，初始sum=0:</p>
<pre><code>tree[1101]=f[13]
tree[1100]=f[9]+...+f[12]
tree[1000]=f[1]+...+f[8]
c[1101]=f[1]+...+f[13]=tree[1101]+tree[1100]+tree[1000]
`&lt;/pre&gt;

![](http://olrdynjoh.bkt.clouddn.com/1.6.png)

read函数迭代的次数是idx二进制表示中位的个数，其最大值为log(MaxVal)。 在本文中MaxVal=16。

&lt;pre&gt;`时间复杂度：O(log MaxVal)
代码长度：不到10行
`&lt;/pre&gt;

## 改变某个位置的频率并且更新数组

当我们改变f数组中的某个值，比如f[idx]，那么tree数组中哪些元素需要改变呢？ 在读取累积频率一节，我们每累加一次tree[idx]，就将idx最后一个1移除， 然后重复该操作。而如果我们改变了f数组，比如f[idx]增加val，我们则需要为当前索引的 tree数组增加val：tree[idx]　+= val。然后idx更新为idx加上其最后的一个1， 当idx不大于MaxVal时，不断重复上面的两个操作。详情见以下C++函数：

![](http://olrdynjoh.bkt.clouddn.com/change.png)

接下来让我们来看一个例子，当idx=5时：

![](http://olrdynjoh.bkt.clouddn.com/1.7.png)

使用上面的算法或者按照图1.6的箭头所示去操作，我们即可更新BIT。

&lt;pre&gt;`时间复杂度：O(log MaxVal)
代码长度：不到10行
`&lt;/pre&gt;

## 读取某个位置的实际频率

上面我们已经讨论了如何读取指定索引的累积频率值(即c[idx])，很明显我们无法通过 tree[idx]直接读取某个位置的实际频率f[idx]。有人说，我们另外再开一个数组来存储f数 组不就可以了。这样一来，读和存f[idx]都只需要O(1)的时间，而空间复杂度则是O(n)的。 不过如果考虑到节约内存空间是更重要的话，我们就不能这么做了。接下来我们将展示在不 增加内存空间的情况下，如何读取f[idx]。(事实上，本文所讨论的问题都是基于我们只维 护一个tree数组的前提)

事实上，有了前面的讨论，要得到f[idx]是一件非常容易的事： f[idx] = read[idx] - read[idx-1]。即前idx个数的和减去前idx-1个数的和， 然后就是f[idx]了。这种方法的时间复杂度是2*O(log n)。下面我们将重新写一个函数， 来得到一个稍快一点的版本，但其本质思想其实和read[idx]-read[idx-1]是一样的。

假如我们要求f[12]，很明显它等于c[12]-c[11]。根据上文讨论的规律，有如下的等式: (为了方便理解，数字写成二进制的表示)

&lt;pre&gt;`c[12]=c[1100]=tree[1100]+tree[1000]
c[11]=c[1011]=tree[1011]+tree[1010]+tree[1000]
f[12]=c[12]-c[11]=tree[1100]-tree[1011]-tree[1010]
`&lt;/pre&gt;

从上面3个式子，你发现了什么？没有错，c[12]和c[11]中包含公共部分，而这个公共部分 在实际计算中是可以不计算进来的。那么，以上现象是否具有一般规律性呢？或者说， 我怎么知道，c[idx]和c[idx-1]的公共部分是什么，我应该各自取它们的哪些tree元素来做 差呢？下面将进入一般性的讨论。

让我们来考察相邻的两个索引值idx和idx-1。我们记idx-1的二进制表示为a0b(b全为1)， 那么idx即a0b+1=a1b^- .(b^- 全为0)。使用上文中读取累积频率的算法(即read函数) 来计算c[idx]，当sum加上tree[idx]后(sum初始为0)，idx减去最后的1得a0b^- , 我们将它记为z。

用同样的方法去计算c[idx-1]，因为idx-1的二进制表示是a0b(b全为1)，那么经过一定数量 的循环后，其值一定会变为a0b^- ,(不断减去最后的1)，而这个值正是上面标记的z。那么， 到这里已经很明显了，z往后的tree值是c[idx]和c[idx-1]都共有的， 相减只是将它们相互抵消，所以没有必要往下再计算了。

也就是说，c[idx]-c[idx-1]等价于取出tree[idx]，然后当idx-1不等于z时，不断地减去 其对应的tree值，然后更新这个索引(减去最后的1)。当其等于z时停止循环(从上面的分析 可知，经过一定的循环后，其值必然会等于z)。下面是C++函数：

![](http://olrdynjoh.bkt.clouddn.com/readf.png)

下面我们来看看根据这个算法，f[12]是怎么计算出来的：

首先，计算z值：z = 12 - (12 &amp;amp; -12) = 8，sum = tree[12] = 11(见表1.1)

![](http://olrdynjoh.bkt.clouddn.com/1.10.png)

对比该算法及调用两次read函数的方法，当idx为奇数时，该算法的时间复杂度仅为O(1)， 迭代次数为0。而对于几乎所有的偶数idx，其时间复杂度为c_O(log idx)， 其中c严格小于1。而read(idx)-read(idx-1)的时间复杂度为c1_O(log idx)， 其中c1总是大于1.

&lt;pre&gt;`时间复杂度：c*O(log MaxVal),c严格小于1
代码长度：不到15行
</code></pre><h2 id="缩放整个数状数组"><a href="#缩放整个数状数组" class="headerlink" title="缩放整个数状数组"></a>缩放整个数状数组</h2><p>这里就省略掉了，如有需要请看作者原文。</p>
<h2 id="返回指定累积频率的索引"><a href="#返回指定累积频率的索引" class="headerlink" title="返回指定累积频率的索引"></a>返回指定累积频率的索引</h2><p>问题可描述为：给你一个累积频率值cumFre，如果存在c[idx]=cumFre，则返回idx； 否则返回-1。该问题最朴素及最简单的解决方法是求出依次求出c[1]到c[MaxVal]， 然后与给出的cumFre对比，如果存在c[idx]=cumFre，则返回idx;否则返回-1。 如果f数组中存在负数，那么该方法就是唯一的解决方案。但如果f数组是非负的， 那么c数组一定是非降的。即如果i&gt;=j，则c[i]&gt;=c[j]。这种情况下，利用二分查找的思想， 我们可以写出时间复杂度为O(log n)的算法。我们从MaxVal的最高位开始(比如本文中 MaxVal是16,所以tIdx从二进制表示10000即16开始)，比较cumFre和tree[tIdx] 的值，根据其比较结果，决定在大的一半区间还是在小的一半区间继续进行查找。 C++函数如下：(如果c数组中存在多个cumFre，find函数返回任意其中一个，findG返回最大 的idx值)</p>
<p><img src="http://olrdynjoh.bkt.clouddn.com/find.png" alt=""></p>
<h2 id="2D-BIT-Binary-Indexed-Trees"><a href="#2D-BIT-Binary-Indexed-Trees" class="headerlink" title="2D BIT(Binary Indexed Trees)"></a>2D BIT(Binary Indexed Trees)</h2><p>这里省略，如有需求请看作者原文。</p>
<h2 id="问题样例"><a href="#问题样例" class="headerlink" title="问题样例"></a>问题样例</h2><p>描述：</p>
<p>n张卡片摆成一排，分别为第1张到第n张，开始时它们都是下面朝下的。你有两种操作：</p>
<p>T(i,j):将第i张到第j张卡片进行翻转，包含i和j这两张。(正面变反面，反面变正面)<br>Q(i):如果第i张卡片正面朝下，返回0；否则返回1.<br>解决方案：</p>
<p>操作1和操作2都有O(log n)的解决方案。设数组f初始全为0，当做一次T(i, j)操作后， 将f[i]加1，f[j+1]减1.这样一来，当我们做一次Q(i)时，只需要求f数组的前i项和c[i] ，然后对2取模即可。结合图2.0，当我们做完一次T(i, j)后，f[i]=1，f[j+1]=-1。 这样一来，当k&lt;i时，c[k]%2=0，表明正面朝下；当i&lt;=k&lt;=j时，c[k]%2=1，表明正面朝 上(因为这区间的卡片都被翻转了！)；当k&gt;j时，c[k]%2=0，表示卡片正面朝下。 Q(i)返回的正是我们要的判断。</p>
<p>注意：这里我们使用BIT结构，所以只维护了一个tree数组，并没有维护f数组。 所以，虽然做一次T(i, j)只需要使f[i]加1，f[j+1]减1，但更新tree数组还是需要 O(log n)的时间；而读取c[k]的时间复杂度也是O(log n)。这里其实只用到了一维BIT 的update函数和read函数。</p>
<p><img src="http://olrdynjoh.bkt.clouddn.com/2.0.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>树状数组十分容易进行编程实现</li>
<li>树状数组的每个操作花费常数时间或是(log n)的时间</li>
<li>数状数组需要线性的存储空间(O(n)，只维护tree数组)</li>
<li>树状数组可扩展成n维的情况</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] RMQ</p>
<p>[2] Binary Search</p>
<p>[3] Peter M. Fenwick</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/head_pic.jpg"
               alt="hys" />
          <p class="site-author-name" itemprop="name">hys</p>
           
              <p class="site-description motion-element" itemprop="description">ZJU SE</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">140</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hys</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
